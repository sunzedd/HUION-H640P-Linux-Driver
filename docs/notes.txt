Вывести информацию о всех устройствах ввода, подключенных к системе можно
с помощью ВФС proc:

        cat /proc/bus/input/devices

Для подключенного графического планшета huion выводятся следующие записи:

I: Bus=0003 Vendor=256c Product=006d Version=0111
N: Name="HID 256c:006d Pen"
P: Phys=usb-0000:00:14.0-9/input0
S: Sysfs=/devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0/0003:256C:006D.0003/input/input26
U: Uniq=
H: Handlers=mouse4 event20 //!!!!!!!!!!!!!!!!!!!!!!11
B: PROP=2
B: EV=1b
B: KEY=1c01 0 0 0 0 0
B: ABS=1000003
B: MSC=10

cat /dev/input/mouse4:
    Реагирует на перемещение стилуса по планшету (в том числе и над планшетом).
cat /dev/input/event20:
    Как и mouse4, но паттерн вывода отличается


I: Bus=0003 Vendor=256c Product=006d Version=0111
N: Name="HID 256c:006d Pad"
P: Phys=usb-0000:00:14.0-9/input0
S: Sysfs=/devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0/0003:256C:006D.0003/input/input27
U: Uniq=
H: Handlers=event21 js0 //!!!!!!!!!!!!!!!!!!!
B: PROP=0
B: EV=1b
B: KEY=800 30000000003ff 0 0 0 0
B: ABS=3
B: MSC=10

cat /dev/input/event21:
    Реагирует только на нажатие всех 6 кнопок на планшете.
cat /dev/input/js0:
    Реагирует на нажатие 6 кнопок на планшете, но с другим паттерном.
    Также реагирует на нажатие одной кнопки на стилусе.
    
    
lsusb -v Выводит информацию о всех юсб устройствах.
Для планшета имеется следующий вывод:

...
bNumConfigurations:	1
Configuration Descriptor:
	...
	bNumInterfaces:	2 		!!!
	
	Interface Descriptor:
		...
		bNumEndpoints:		1
		...
		bInterfaceNumber: 	0
		bInterfaceClass: 	1 Human Interface Device
		bInterfaceProtocol:	2 Mouse
		iInterface: 		0
    		
    		...
    		    HID Device Descriptor
    		...
    		
    		Endpoint Descriptor:
    			bLength:		7
    			bEndpointAddress:	0x81 EP 1 IN
    			bmAttributes:		3
    				Transfer Type:		Interrupt
    				Synch Type:		None
    				Usage Type:		Data
    			wMaxPacketSize:	0x0040 1x 64 bytes
    			bInterval:		2
    			
    			
    	Interface Descriptor:
    		bNumEndpoints:		1
    		bInterfaceClass: 	1 Human Interface Device
		bInterfaceProtocol:	2 Mouse
		
    		...
    		    HID Device Descriptor
    		...
    		
    		Endpoint Descriptor:		
    			bLength:		7
    			bEndpointAddress:	0x82 EP 2 IN
    			bmAttributes:		3
    				Transfer Type:		Interrupt
    				Synch Type:		None
    				Usage Type:		Data
    			wMaxPacketSize:	0x0010 1x 16 bytes
    			bInterval:		2
    			
!!!
Напомним, что в обратных вызовах probe и disconnect, которые выполняются
ядром USB для каждого интерфейса зарегистрированного устройства, в
качестве первого параметра указывается дескриптор соответствующего интерфейса.

int (*probe)(struct usb_interface *interface, const struct usb_device_id *id);
void (*disconnect)(struct usb_interface *interface);

	Оба интерфейса имеют по одному endpoint-у, настроенных в режиме IN (Действительно,
планшет - это устройство ввода и выводить данные с машины на него звучит 
бессмысленно).
	Нужно опредеделить, какой интерфейс устройства является интерфейсом планшета,
а какой - стилуса. В lsusb -v они оба работают по протоколу мыши. У них различаются
размер пакета и размер дескриптора HID-устройства.

	Судя по заметке о выводе содержимого  /proc, первый интерфейс - это стилус (Pen),
второй интерфейс - планшет (Pad).

	Использование символьных драйверов осуществляется через соответствующие файлы 
символьных устройств, которые прикомпонованы к виртуальной файловой системе (VFS). 
Это означает, что приложение выполняет обычные файловые операции с файлом 
символьного устройства. Эти операции будут перетранслированы виртуальной файловой 
системой VFS в соответствующие функции в прикомпонованном драйвере символьного устройства. 
Затем для того, чтобы получить нужные результаты, с помощью этих функций 
осуществляется окончательный низкоуровневый доступ к реальному устройству.
    
	Приложение подключается к файлу устройства при помощи системного вызова open, открывающего файл устройства.

	Файлы устройств подключаются к драйверу устройства с помощью специального 
механизма регистрации, что осуществляется драйвером. Драйвер связывается с устройством 
с помощью специальных низкоуровневых операций, характерных для конкретного устройства.
Таким образом, мы формируем полное соединение.

	При подключении приложения к файлу устройства используется имя файла устройства.
Но при подключении файла устройства к драйверу устройства используется номер файла
устройства, а не имя файла. используют пару чисел <major, minor>.

	С помощью следующей команды можно будет выдать список файлов различных символьных 
устройств, имеющихся в вашей системе:
$ ls -l /dev/ | grep "^c"
c - character.

	struct usb_device представляет физическое USB устройство,
	struct usb_interface представляет конкретный интерфейс этого устройства.
	Эти структуры представляются в sysfs как отдельные устройства, так как они 
содержат struct device.

---------------------------- URB ----------------------------------------------
struct urb: inlude/linux/usb.h

urb используется для отправки и получения данных в/с конкретного endpoint конкретного
устройства в ассинхронной манере.
	Драйвер usb устройства может аллоцировать несколько urb для одного endpoint-а,
либо один urb на несколько endpoint-ов. Каждый endpoint может обрабатывать очередь
из urb. Urb могут быть отменены драйвером, в случае если устройство было отключено.

	usb_fill_int_urb is a helper function to properly initialize a urb to be
sent to a interrupt endpoint of a USB device:
	
	void usb_fill_int_urb(struct urb *urb, struct usb_device *dev,
						  unsigned int pipe, void *transfer_buffer,
						  int buffer_length, usb_complete_t complete,
						  void *context, int interval);

    int interval - The interval at which that this urb should be scheduled.
В нашем случае - 2 милисекунды.


	However EV_ABS requires a little special care. Before calling input_register_device,
you have to fill additional fields in the input_dev struct for each absolute
axis your device has. If our button device had also the ABS_X axis:

button_dev.absmin[ABS_X] = 0;
button_dev.absmax[ABS_X] = 255;
button_dev.absfuzz[ABS_X] = 4;
button_dev.absflat[ABS_X] = 8;

Or, you can just say:

input_set_abs_params(button_dev, ABS_X, 0, 255, 4, 8);

	This setting would be appropriate for a joystick X axis, with the minimum of 0,
maximum of 255 (which the joystick must be able to reach, no problem if it
sometimes reports more, but it must be able to always reach the min and max values),
with noise in the data up to +- 4, and with a center flat position of size 8.
    
